#+TITLE:  DBC.jl
#+AUTHOR: Guilherme Gomes Haetinger

[[https://travis-ci.com/github/GuilhermeHaetinger/DBC.jl][https://travis-ci.com/GuilhermeHaetinger/DBC.jl.svg?branch=main&status=passed]]
[[https://codecov.io/gh/GuilhermeHaetinger/DBC.jl][https://codecov.io/gh/GuilhermeHaetinger/DBC.jl/branch/main/graph/badge.svg]]

* Description
This package provides an interface for *Design By Contract* programming in
Julia. The method for software design was first introduced in the *Eiffel*
programming language and has been adapted to other production languages such as
Java and C++. It has since been praised by producing readable, easily testable
code.

*Design By Contract* prescribes formal conditions to the execution of a method.
One must define the prerequisites and post-conditions expected so that the
function is better described and, thus, contributes to the general safety of the
program's state.

Our goal is to produce an alternative package to *Contracts.jl*, which seems to
have been discontinued.

* Installation
This package hasn't been added to the main Julia repository yet. To use it, one
must run:

#+BEGIN_SRC
pkg> add https://github.com/GuilhermeHaetinger/DBC.jl
#+END_SRC

* Usage

*DBC.jl* works by processing a block containing the prerequisites,
post-conditions and the contract's function.

** Prerequisites

Prerequisites have the unique goal of filtering the arguments of the function
and blocking invalid ones that come from different parts of a program. This can
help finding errors in other functionalities as soon as possible. Here is an
example of a function that has prerequisites breached:

#+BEGIN_SRC julia :session dbc :result output :exports both
using DBC

maxDictSize = 2

# Function for adding a variable to a string-key dictionary with a non-null key
@contract begin
    require(length(dict) < maxDictSize, length(key) > 0)
    function putItem!(dict :: Dict{String, Any}, key :: String, item)
        dict[key] = item
        return nothing
    end
end
#+END_SRC

#+RESULTS:
: putItem! (generic function with 1 method)

#+BEGIN_SRC julia :session dbc :result output :exports both
fruits = Dict{String, Any}()

putItem!(fruits, "apple", :red)
fruits
#+END_SRC

#+RESULTS:
: Dict{String,Any} with 1 entry:
:   "apple" => :red

#+BEGIN_SRC julia :session dbc :result output :exports both
putItem!(fruits, "blueberry", :blue)
fruits
#+END_SRC

#+RESULTS:
: Dict{String,Any} with 2 entries:
:   "apple"     => :red
:   "blueberry" => :blue

#+BEGIN_SRC julia :session dbc :result output :exports both
putItem!(fruits, "", :purple)
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]
: Breach on Requirement Expression 'length(dict) < maxDictSize' in function 'putItem!'
:
: Stacktrace:
:  [1] putItem! at ./In[15]:0 [inlined] (repeats 2 times)
:  [2] top-level scope at In[18]:1
:END:

#+BEGIN_SRC julia :session dbc :result output :exports both
delete!(fruits, "blueberry")
putItem!(fruits, "", :purple)
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]
: Breach on Requirement Expression 'length(key) > 0' in function 'putItem!'
:
: Stacktrace:
:  [1] putItem! at ./In[15]:0 [inlined] (repeats 2 times)
:  [2] top-level scope at In[19]:2
:END:

** Post-conditions

Post-conditions work to find errors inside the contracted function. It is also
used to find errors easily and as soon as possible. Here is an example of a
function that breaches its post-conditions:

#+BEGIN_SRC julia :session dbc :result output :exports both

minVal = 5

# Function that adds 1 to the values
# of an int array with len > 5
# and guarantees the sum of its elements
# will be > minVal
@contract begin
    require(length(arr) >= 5)
    ensure(sum(arr) > minVal)
    function incrArr!(arr :: Array{Int64, 1})
        for index in 1:length(arr)
            arr[index] += 1
        end
        return nothing
    end
end
#+END_SRC

#+RESULTS:
: incrArr! (generic function with 1 method)

#+BEGIN_SRC julia :session dbc :result output :exports both
arr = collect(1:5)
display(arr)
incrArr!(arr)
arr
#+END_SRC

#+RESULTS:
:RESULTS:
: 5-element Array{Int64,1}:
:  1
:  2
:  3
:  4
:  5
: 5-element Array{Int64,1}:
:  2
:  3
:  4
:  5
:  6
:END:

#+BEGIN_SRC julia :session dbc :result output :exports both
arr = collect(ones(Int64, 5))
display(arr)
incrArr!(arr)
arr
#+END_SRC

#+RESULTS:
:RESULTS:
: 5-element Array{Int64,1}:
:  1
:  1
:  1
:  1
:  1
: 5-element Array{Int64,1}:
:  2
:  2
:  2
:  2
:  2
:END:

#+BEGIN_SRC julia :session dbc :result output :exports both
arr = collect(-1 .* ones(Int64, 5))
display(arr)
incrArr!(arr)
arr
#+END_SRC

#+RESULTS:
:RESULTS:
: 5-element Array{Int64,1}:
:  -1
:  -1
:  -1
:  -1
:  -1
# [goto error]
: Breach on Ensure Expression 'sum(arr) > minVal' in function 'incrArr!'
:
: Stacktrace:
:  [1] incrArr!(::Array{Int64,1}) at ./In[24]:15
:  [2] top-level scope at In[27]:3
:END:

*** Return contract

It's important to make sure there are =return= expressions where you want to
return a value. This is both to make sure you understand the endpoints of the
function and to enable the macro =@contract= to see them as well. This helps
when you want to ensure the result value. Having this said, we can use the name
=result= inside =ensure= expressions to test the returning value. The following
is an example:

#+BEGIN_SRC julia :session dbc :result output :exports both
# returns the value of a sum or product operation in
# an integer array depending on the parity of it's size.
# Says the final value is positive
@contract begin
    ensure(result > 0)
    function processArr(arr :: Array{Int64, 1})
        if length(arr) % 2 == 0
            return prod(arr)
        else
            return sum(arr)
        end
    end
end
#+END_SRC

#+RESULTS:
: processArr (generic function with 1 method)

#+BEGIN_SRC julia :session dbc :result output :exports both
processArr([1, 2, 3])
#+END_SRC

#+RESULTS:
: 6

#+BEGIN_SRC julia :session dbc :result output :exports both
processArr([2, 2, 2, 2])
#+END_SRC

#+RESULTS:
: 16

#+BEGIN_SRC julia :session dbc :result output :exports both
processArr([1, 2, 3, -1])
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]
: Breach on Ensure Expression 'result > 0' in function 'processArr'
:
: Stacktrace:
:  [1] processArr(::Array{Int64,1}) at ./In[5]:8
:  [2] top-level scope at In[8]:1
:END:

*** Return name

Since there could probably be variables in your function with =result= as name,
there is an extra sub-agreement in the contract block to change the =result=
name. This sub-agreement is the attribution to the name =returnName=, e. g.:

#+BEGIN_SRC julia :session dbc :result output :exports both
# Like the last example but with a twist
@contract begin
    returnName = returnValue
    ensure(returnValue > 0)
    function newProcessArr(arr :: Array{Int64, 1})
        result = 0
        if length(arr) % 2 == 0
            result = prod(arr)
        else
            result = sum(arr)
        end
        return -1 * result
    end
end
#+END_SRC

#+RESULTS:
: newProcessArr (generic function with 1 method)

#+BEGIN_SRC julia :session dbc :result output :exports both
newProcessArr([1, 2, 3, -1])
#+END_SRC

#+RESULTS:
: 6

#+BEGIN_SRC julia :session dbc :result output :exports both
newProcessArr([2, 2, 2, 2])
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]
: Breach on Ensure Expression 'returnValue > 0' in function 'newProcessArr'
:
: Stacktrace:
:  [1] newProcessArr(::Array{Int64,1}) at ./In[14]:12
:  [2] top-level scope at In[16]:1
:END:


* TODOs
** [ ] Add function invariant
** [ ] Add loop invariant
** [ ] Add old value call
** [ ] Enable assertion disabling for efficiency
** [ ] Add DocStrings
